searchState.loadedDescShard("vinylla", 0, "Serato Control CD 1.0.0\nLow level bitwise operations\nThe <code>Bitstream</code> struct processes bits and maps them to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nImplementation of a Fibonacci Linear Feedback Shift …\nHelper Utilities\nShift all bits in <code>size</code>-bit integer <code>data</code> to the left and …\nShift all bits in <code>size</code>-bit integer <code>data</code> to the right and …\nReturn 2^size - 1 that can be used as a bitmask\nShift all bits in <code>size</code>-bit integer <code>data</code> to the left and …\nShift all bits in <code>size</code>-bit integer <code>data</code> to the right and …\nMaps a bitstream to a position in the underlying lookup …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the position is considered valid.\nCreate a timecode bitstream using a LFSR with length …\nRetrieve the Position from the current bitstream.\nProcess a single bit in forwards direction.\nProcess a single bit in backwards direction.\nReturns the current state of the bitstream\nSerato Control CD 1.0.0\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nFibonacci Linear Feedback Shift Register (LFSR)\nAdvance the LFSR state and return it.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturn the next LFSR state (without making any changes).\nReturn the previous LFSR state (without making any …\nRevert the LFSR state and return it.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReads a bit from the sample and adjust the threshold.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns true if the wave has crossed zero.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nProcess a sample and detect zero crossing.\nReturns the current state of the bitstream\nDiscrete-time implementation of a simple RC low-pass …\nCalculate the smoothing factor.\nCalculate the difference between the current input and …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe smoothed last output.\nCalculate the next smoothed value and store it.\nCalculate the next smoothed value.\nThe smoothing factor (commonly named α in literature). …")